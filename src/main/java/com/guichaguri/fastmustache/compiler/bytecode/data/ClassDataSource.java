package com.guichaguri.fastmustache.compiler.bytecode.data;

import com.guichaguri.fastmustache.compiler.bytecode.CompilerException;
import com.guichaguri.fastmustache.compiler.bytecode.CompilerUtils;
import com.guichaguri.fastmustache.compiler.bytecode.LocalVariable;
import com.guichaguri.fastmustache.compiler.util.resolver.ClassMemberResolver;
import com.guichaguri.fastmustache.template.*;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Type;

import static com.guichaguri.fastmustache.compiler.bytecode.BytecodeGenerator.*;
import static org.objectweb.asm.Opcodes.*;

/**
 * Generates the bytecode that gets data from a key using the fields or methods from a class.
 *
 * The generated bytecode is faster than {@link SimpleDataSource} and {@link TypedDataSource}
 *
 * @author Guichaguri
 */
public class ClassDataSource implements DataSource {
    private final Class<?> clazz;
    private final Type clazzType;
    private final ClassMemberResolver resolver;

    public ClassDataSource(Class<?> clazz) {
        this(clazz, ClassMemberResolver.getInstance());
    }

    public ClassDataSource(Class<?> clazz, ClassMemberResolver resolver) {
        this.clazz = clazz;
        this.clazzType = Type.getType(clazz);
        this.resolver = resolver;
    }

    @Override
    public Type getDataType() {
        return clazzType;
    }

    @Override
    public Class<?> getDataClass() {
        return clazz;
    }

    @Override
    public MustacheType getType(DataSourceContext context, String key) {
        LinkedList<LocalVariable> vars = context.vars;

        for(int i = vars.size() - 1; i >= 0; i--) {
            MustacheType type = getType(vars.get(i).descClass, key);
            if(type != MustacheType.UNKNOWN) return type;
        }

        return getType(clazz, key);
    }

    @Override
    public void insertObjectGetter(DataSourceContext context, String key) throws CompilerException {
        MemberType type = insertGetter(context, key, true);

        if(type.clazz.isPrimitive()) {
            throw new CompilerException(key + " does not allow primitive types (" + type + ")");
        }
    }

    @Override
    public MemberType insertDataGetter(DataSourceContext context, String key) throws CompilerException {
        // Inserts a generic getter.
        // It doesn't matter whether the type is an object or primitive, it can be used in both ways.
        return insertGetter(context, key, true);
    }

    @Override
    public void insertStringGetter(DataSourceContext context, String key, boolean escaped) throws CompilerException {
        Class<?> type = insertGetter(context, key, true).clazz;
        MethodVisitor mv = context.mv;

        // String.valueOf(...)
        if(type.isPrimitive()) {
            mv.visitMethodInsn(INVOKESTATIC, STRING.getInternalName(), "valueOf",
                    Type.getMethodDescriptor(STRING, Type.getType(type)), false);
        } else if(!String.class.isAssignableFrom(type)) {
            mv.visitMethodInsn(INVOKESTATIC, STRING.getInternalName(), "valueOf",
                    Type.getMethodDescriptor(STRING, OBJECT), false);
        }

        // TemplateUtils.escapeString(...)
        if(escaped) {
            mv.visitMethodInsn(INVOKESTATIC, UTILS.getInternalName(), "escapeString",
                    Type.getMethodDescriptor(STRING, STRING), false);
        }
    }

    @Override
    public void insertBooleanGetter(DataSourceContext context, String key) throws CompilerException {
        Class<?> type = insertGetter(context, key, true).clazz;
        MethodVisitor mv = context.mv;

        if(type == boolean.class) {
            // The correct type. We don't need to adapt it :D
            return;
        }

        if(type == Boolean.class) {
            // b.booleanValue()
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false);
        } else if(type.isPrimitive()) {
            throw new CompilerException("Can't convert a primitive into a boolean: " + type + ". (" + key + ")");
        } else {
            // Boolean.parseBoolean(object.toString())

            if (type != String.class) {
                mv.visitMethodInsn(INVOKEVIRTUAL, OBJECT.getInternalName(), "toString", Type.getMethodDescriptor(STRING), false);
            }
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "parseBoolean", Type.getMethodDescriptor(STRING, Type.BOOLEAN_TYPE), false);
        }
    }

    @Override
    public void insertTypeGetter(DataSourceContext context, String key) {
        int type = getType(context, key).ordinal();

        // Loads the ordinal number into the stack
        CompilerUtils.loadInteger(context.mv, type);
    }

    @Override
    public MemberType insertArrayGetter(DataSourceContext context, String key) throws CompilerException {
        MemberType type = insertGetter(context, key, false);

        if(!type.clazz.isArray() && !Collection.class.isAssignableFrom(type.clazz)) {
            throw new CompilerException("Can't convert " + type + " into an array or collection. (" + key + ")");
        }

        return type;
    }

    @Override
    public MemberType insertLambdaGetter(DataSourceContext context, String key) throws CompilerException {
        MemberType type = insertGetter(context, key, false);

        if(!MustacheLambda.class.isAssignableFrom(type.clazz)) {
            throw new CompilerException("Can't convert " + type + " into a mustache lambda. (" + key + ")");
        }

        Class<?> dataObject = type.getComponent(MustacheLambda.class);
        if (dataObject == null) dataObject = Object.class;

        return new MemberType(dataObject, Type.getType(dataObject));
    }

    @Override
    public void insertPartialGetter(DataSourceContext context, String key) throws CompilerException {
        MemberType type = insertGetter(context, key, false);

        if(!Template.class.isAssignableFrom(type.clazz)) {
            throw new CompilerException("Can't convert " + type + " into a template. (" + key + ")");
        }

        Class<?> dataClass = type.getComponent(Template.class);
        if (dataClass == null) dataClass = Object.class;

        LinkedList<LocalVariable> vars = context.vars;

        for(int i = vars.size() - 1; i >= 0; i--) {
            LocalVariable var = vars.get(i);
            if (dataClass.isAssignableFrom(var.descClass)) {
                var.load(context.mv);
                return;
            }
        }

        throw new CompilerException("No variable found that matches " + dataClass + ". (" + key + ")");
    }

    @Override
    public void loadDataItem(DataSourceContext context, LocalVariable var) {
        context.vars.add(var);
    }

    @Override
    public void unloadDataItem(DataSourceContext context, LocalVariable var) {
        context.vars.remove(var);
    }

    @Override
    public List<LocalVariable> getDataContext(DataSourceContext context) {
        return context.vars;
    }

    private MustacheType getType(Class<?> clazz, String key) {
        Member[] members = resolver.findPath(clazz, key);

        if (members == null || members.length == 0) {
            return MustacheType.UNKNOWN;
        }

        Member last = members[members.length - 1];

        if (last instanceof Method) {
            return MustacheType.getByClass(((Method) last).getReturnType());
        } else if (last instanceof Field) {
            return MustacheType.getByClass(((Field) last).getType());
        }

        return MustacheType.UNKNOWN;
    }

    /**
     * Searches and inserts a getter, loading the key into the stack
     * @param context The context
     * @param key The key
     * @param basicType Whether the type returned will not contain the component
     * @return The type added to the stack
     */
    private MemberType insertGetter(DataSourceContext context, String key, boolean basicType) throws CompilerException {
        LinkedList<LocalVariable> vars = context.vars;

        for(int i = vars.size() - 1; i >= 0; i--) {
            MemberType type = insertGetter(context.mv, vars.get(i), key, basicType);
            if(type != null) return type;
        }

        throw new CompilerException("Couldn't find any field or method related to " + key);
    }

    /**
     * Tries to inserts a getter, loading the key into the stack
     * @param mv The method visitor
     * @param var The data local variable
     * @param key The key
     * @param basicType Whether the type returned will not contain the component
     * @return The type added to the stack or {@code null} if nothing was added
     */
    private MemberType insertGetter(MethodVisitor mv, LocalVariable var, String key, boolean basicType) {
        Class<?> clazz = var.descClass;

        if (TemplateUtils.isImplicitIterator(key)) {
            // Implicit iterator - We'll return the variable itself instead of looking for a property
            var.load(mv);
            return new MemberType(clazz, Type.getType(clazz));
        }

        Member[] members = resolver.findPath(clazz, key);
        if(members == null || members.length == 0) {
            return null;
        }

        // Loads the variable into the stack
        var.load(mv);

        for(int i = 0; i < members.length; i++) {
            Member member = members[i];
            boolean last = i == members.length - 1;

            if(member instanceof Method) {

                // Inserts a method invocation
                Method method = (Method)member;
                Class<?> returnClass = method.getReturnType();
                Class<?> declaringClass = method.getDeclaringClass();
                Type returnType = Type.getType(returnClass);
                boolean itf = declaringClass.isInterface();

                mv.visitMethodInsn(itf ? INVOKEINTERFACE : INVOKEVIRTUAL, Type.getInternalName(declaringClass),
                        method.getName(), Type.getMethodDescriptor(returnType), itf);

                if(last) {
                    return basicType ? new MemberType(returnClass, returnType) : new MemberType(method, returnType);
                }

            } else if(member instanceof Field) {

                // Inserts a field retrieval
                Field field = (Field)member;
                Class<?> fieldClass = field.getType();
                Type fieldType = Type.getType(fieldClass);

                mv.visitFieldInsn(GETFIELD, Type.getInternalName(field.getDeclaringClass()),
                        field.getName(), fieldType.getDescriptor());

                if(last) {
                    return basicType ? new MemberType(fieldClass, fieldType) : new MemberType(field, fieldType);
                }

            }
        }

        // The code should never reach here
        return null;
    }

}
