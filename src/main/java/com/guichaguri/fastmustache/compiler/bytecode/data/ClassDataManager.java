package com.guichaguri.fastmustache.compiler.bytecode.data;

import com.guichaguri.fastmustache.compiler.CompilerException;
import com.guichaguri.fastmustache.template.MustacheType;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.LinkedList;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Type;

import static com.guichaguri.fastmustache.compiler.bytecode.BytecodeGenerator.*;
import static org.objectweb.asm.Opcodes.*;

/**
 * Generates the bytecode that gets data from a key using the fields or methods from a class.
 *
 * The generated bytecode is faster than {@link TemplateDataManager} and {@link TypedDataManager}
 *
 * @author Guichaguri
 */
public class ClassDataManager implements DataManager {
    private final Class<?> clazz;
    private final Type clazzType;

    private LinkedList<Integer> vars = new LinkedList<>();
    private LinkedList<Class<?>> classes = new LinkedList<>();

    public ClassDataManager(Class<?> clazz, Type type) {
        this.clazz = clazz;
        this.clazzType = type;
    }

    @Override
    public Type getDataType() {
        return clazzType;
    }

    @Override
    public MustacheType getType(String key) {
        for(int i = classes.size() - 1; i >= 0; i--) {
            MustacheType type = getType(classes.get(i), key);
            if(type != MustacheType.UNKNOWN) return type;
        }

        return getType(clazz, key);
    }

    @Override
    public void insertObjectGetter(MethodVisitor mv, int var, String key) throws CompilerException {
        Class<?> type = insertGetter(mv, var, key, true).clazz;

        if(type.isPrimitive()) {
            throw new CompilerException(key + " does not allow primitive types");
        }
    }

    @Override
    public void insertStringGetter(MethodVisitor mv, int var, String key, boolean escaped) throws CompilerException {
        Class<?> type = insertGetter(mv, var, key, true).clazz;

        // String.valueOf(...)
        if(type.isPrimitive()) {
            mv.visitMethodInsn(INVOKESTATIC, STRING.getInternalName(), "valueOf",
                    Type.getMethodDescriptor(STRING, Type.getType(type)), false);
        } else if(!String.class.isAssignableFrom(type)) {
            mv.visitMethodInsn(INVOKESTATIC, STRING.getInternalName(), "valueOf",
                    Type.getMethodDescriptor(STRING, OBJECT), false);
        }

        // TemplateUtils.escapeString(...)
        if(escaped) {
            mv.visitMethodInsn(INVOKESTATIC, UTILS.getInternalName(), "escapeString",
                    Type.getMethodDescriptor(STRING, STRING), false);
        }
    }

    @Override
    public void insertBooleanGetter(MethodVisitor mv, int var, String key) throws CompilerException {
        Class<?> type = insertGetter(mv, var, key, true).clazz;

        if(type == boolean.class) {
            // The correct type. We don't need to adapt it :D
            return;
        }

        if(type == Boolean.class) {
            // b.booleanValue()
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false);
        } else if(type.isPrimitive()) {
            throw new CompilerException("Can't parse a primitive into a boolean: " + type);
        } else {
            // Boolean.parseBoolean(object.toString())
            mv.visitMethodInsn(INVOKEVIRTUAL, OBJECT.getInternalName(), "toString", Type.getMethodDescriptor(STRING), false);
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "parseBoolean", Type.getMethodDescriptor(STRING, Type.BOOLEAN_TYPE), false);
        }
    }

    @Override
    public MemberType insertArrayGetter(MethodVisitor mv, int var, String key) throws CompilerException {
        MemberType type = insertGetter(mv, var, key, false);

        if(!type.clazz.isArray() && !Collection.class.isAssignableFrom(type.clazz)) {
            throw new CompilerException("Can't parse " + type + " into an array or collection");
        }

        return type;
    }

    @Override
    public void loadDataItem(MethodVisitor mv, int var, Class<?> type) {
        vars.add(var);
        classes.add(type);
    }

    @Override
    public void unloadDataItem(MethodVisitor mv, int var) {
        int index = vars.indexOf(var);

        vars.remove(index);
        classes.remove(index);
    }

    private MustacheType getType(Class<?> clazz, String key) {
        Method method = getMethod(clazz, key);
        if(method != null) {
            return getType(method.getReturnType());
        }

        Field field = getField(clazz, key);
        if(field != null) {
            return getType(field.getType());
        }

        return MustacheType.UNKNOWN;
    }

    private MustacheType getType(Class<?> c) {
        if(c.isPrimitive()) {
            if(c == boolean.class) {
                return MustacheType.BOOLEAN;
            }
            return MustacheType.STRING;
        }

        if(Boolean.class.isAssignableFrom(c)) {
            return MustacheType.BOOLEAN;
        } else if(MustacheType.class.isAssignableFrom(c)) {
            return MustacheType.LAMBDA;
        } else if(String.class.isAssignableFrom(c) || Number.class.isAssignableFrom(c)) {
            return MustacheType.STRING;
        } else if(c.isArray() || Collection.class.isAssignableFrom(c)) {
            return MustacheType.ARRAY;
        } else {
            return MustacheType.DATA;
        }
    }

    private MemberType insertGetter(MethodVisitor mv, int var, String key, boolean basicType) throws CompilerException {
        for(int i = vars.size() - 1; i >= 0; i--) {
            MemberType type = insertGetter(mv, classes.get(i), vars.get(i), key, basicType);
            if(type != null) return type;
        }

        MemberType type = insertGetter(mv, clazz, var, key, basicType);
        if(type != null) return type;

        throw new CompilerException("Couldn't find any field or method related to " + key);
    }

    private MemberType insertGetter(MethodVisitor mv, Class<?> clazz, int var, String key, boolean basicType) {
        // data.getKey / data.isKey
        Method method = getMethod(clazz, key);
        if(method != null) {
            Class<?> returnClass = method.getReturnType();
            Type returnType = Type.getType(returnClass);

            boolean itf = method.getDeclaringClass().isInterface();
            mv.visitVarInsn(ALOAD, var);
            mv.visitMethodInsn(itf ? INVOKEINTERFACE : INVOKEVIRTUAL, Type.getInternalName(method.getDeclaringClass()),
                    method.getName(), Type.getMethodDescriptor(returnType), itf);

            return basicType ? new MemberType(returnClass, returnType) : new MemberType(method, returnType);
        }

        // data.key
        Field field = getField(clazz, key);
        if(field != null) {
            Class<?> fieldClass = field.getType();
            Type fieldType = Type.getType(fieldClass);

            mv.visitVarInsn(ALOAD, var);
            mv.visitFieldInsn(GETFIELD, Type.getInternalName(field.getDeclaringClass()),
                    field.getName(), fieldType.getDescriptor());

            return basicType ? new MemberType(fieldClass, fieldType) : new MemberType(field, fieldType);
        }

        return null;
    }

    private Field getField(Class<?> clazz, String key) {
        try {
            return clazz.getField(key);
        } catch(Exception ex) {
            return null;
        }
    }

    private Method getMethod(Class<?> clazz, String key) {
        String camelCase = key.substring(0, 1).toUpperCase() + key.substring(1);
        try {
            return clazz.getMethod("get" + camelCase);
        } catch(Exception ex) {}

        try {
            return clazz.getMethod("is" + camelCase);
        } catch(Exception ex) {}

        return null;
    }
}
