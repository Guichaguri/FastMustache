package com.guichaguri.fastmustache.compiler.bytecode.data;

import com.guichaguri.fastmustache.compiler.CompilerException;
import com.guichaguri.fastmustache.compiler.bytecode.LocalVariable;
import com.guichaguri.fastmustache.template.MustacheType;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.LinkedList;
import com.guichaguri.fastmustache.template.SimpleTemplate;
import com.guichaguri.fastmustache.template.Template;
import com.guichaguri.fastmustache.template.TemplateData;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Type;

import static com.guichaguri.fastmustache.compiler.bytecode.BytecodeGenerator2.*;
import static org.objectweb.asm.Opcodes.*;

/**
 * Generates the bytecode that gets data from a key using the fields or methods from a class.
 *
 * The generated bytecode is faster than {@link SimpleDataManager} and {@link TypedDataManager}
 *
 * @author Guichaguri
 */
public class ClassDataManager implements DataManager {
    private final Class<?> clazz;
    private final Type clazzType;

    private LinkedList<LocalVariable> vars = new LinkedList<>();
    private LinkedList<Class<?>> classes = new LinkedList<>();

    public ClassDataManager(Class<?> clazz, Type type) {
        this.clazz = clazz;
        this.clazzType = type;
    }

    @Override
    public Type getDataType() {
        return clazzType;
    }

    @Override
    public MustacheType getType(String key) {
        for(int i = classes.size() - 1; i >= 0; i--) {
            MustacheType type = getType(classes.get(i), key);
            if(type != MustacheType.UNKNOWN) return type;
        }

        return getType(clazz, key);
    }

    @Override
    public MemberType insertObjectGetter(MethodVisitor mv, LocalVariable var, String key) throws CompilerException {
        MemberType type = insertGetter(mv, var, key, true);

        if(type.clazz.isPrimitive()) {
            throw new CompilerException(key + " does not allow primitive types (" + type + ")");
        }

        return type;
    }

    @Override
    public void insertStringGetter(MethodVisitor mv, LocalVariable var, String key, boolean escaped) throws CompilerException {
        Class<?> type = insertGetter(mv, var, key, true).clazz;

        // String.valueOf(...)
        if(type.isPrimitive()) {
            mv.visitMethodInsn(INVOKESTATIC, STRING.getInternalName(), "valueOf",
                    Type.getMethodDescriptor(STRING, Type.getType(type)), false);
        } else if(!String.class.isAssignableFrom(type)) {
            mv.visitMethodInsn(INVOKESTATIC, STRING.getInternalName(), "valueOf",
                    Type.getMethodDescriptor(STRING, OBJECT), false);
        }

        // TemplateUtils.escapeString(...)
        if(escaped) {
            mv.visitMethodInsn(INVOKESTATIC, UTILS.getInternalName(), "escapeString",
                    Type.getMethodDescriptor(STRING, STRING), false);
        }
    }

    @Override
    public void insertBooleanGetter(MethodVisitor mv, LocalVariable var, String key) throws CompilerException {
        Class<?> type = insertGetter(mv, var, key, true).clazz;

        if(type == boolean.class) {
            // The correct type. We don't need to adapt it :D
            return;
        }

        if(type == Boolean.class) {
            // b.booleanValue()
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Boolean", "booleanValue", "()Z", false);
        } else if(type.isPrimitive()) {
            throw new CompilerException("Can't convert a primitive into a boolean: " + type + ". (" + key + ")");
        } else {
            // Boolean.parseBoolean(object.toString())

            if (type != String.class) {
                mv.visitMethodInsn(INVOKEVIRTUAL, OBJECT.getInternalName(), "toString", Type.getMethodDescriptor(STRING), false);
            }
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/Boolean", "parseBoolean", Type.getMethodDescriptor(STRING, Type.BOOLEAN_TYPE), false);
        }
    }

    @Override
    public MemberType insertArrayGetter(MethodVisitor mv, LocalVariable var, String key) throws CompilerException {
        MemberType type = insertGetter(mv, var, key, false);

        if(!type.clazz.isArray() && !Collection.class.isAssignableFrom(type.clazz)) {
            throw new CompilerException("Can't convert " + type + " into an array or collection. (" + key + ")");
        }

        return type;
    }

    @Override
    public MemberType insertPartialGetter(MethodVisitor mv, LocalVariable var, String key) throws CompilerException {
        MemberType type = insertGetter(mv, var, key, false);
        Class<?> dataClass;

        if(type.clazz == Template.class) {
            dataClass = type.component;
        } else if(type.clazz == SimpleTemplate.class) {
            dataClass = TemplateData.class;
        } else {
            throw new CompilerException("Can't convert " + type + " into a template. (" + key + ")");
        }

        type = new MemberType(dataClass, Type.getType(dataClass));

        for(int i = classes.size() - 1; i >= 0; i--) {
            if (dataClass.isAssignableFrom(classes.get(i))) {
                vars.get(i).load(mv);
                return type;
            }
        }

        if (dataClass.isAssignableFrom(clazz)) {
            var.load(mv);
            return type;
        }

        throw new CompilerException("No variable found that matches " + dataClass + ". (" + key + ")");
    }

    @Override
    public void loadDataItem(MethodVisitor mv, LocalVariable var, Class<?> type) {
        vars.add(var);
        classes.add(type);
    }

    @Override
    public void unloadDataItem(MethodVisitor mv, LocalVariable var) {
        int index = vars.indexOf(var);

        vars.remove(index);
        classes.remove(index);
    }

    private MustacheType getType(Class<?> clazz, String key) {
        Member[] members = findPath(clazz, key);

        if (members == null || members.length == 0) {
            return MustacheType.UNKNOWN;
        }

        Member last = members[members.length - 1];

        if (last instanceof Method) {
            return getType(((Method) last).getReturnType());
        } else if (last instanceof Field) {
            return getType(((Field) last).getType());
        }

        return MustacheType.UNKNOWN;
    }

    private MustacheType getType(Class<?> c) {
        if(c.isPrimitive()) {
            if(c == boolean.class) {
                return MustacheType.BOOLEAN;
            }

            // Any primitive can be converted into a string
            return MustacheType.STRING;
        }

        if(Boolean.class.isAssignableFrom(c)) {
            return MustacheType.BOOLEAN;
        } else if(MustacheType.class.isAssignableFrom(c)) { // TODO?
            return MustacheType.LAMBDA;
        } else if(String.class.isAssignableFrom(c) || Number.class.isAssignableFrom(c)) {
            return MustacheType.STRING;
        } else if(c.isArray() || Collection.class.isAssignableFrom(c)) {
            return MustacheType.ARRAY;
        } else if(Template.class.isAssignableFrom(c)) {
            return MustacheType.PARTIAL;
        } else {
            // Any other object can be treated as data
            return MustacheType.DATA;
        }
    }

    /**
     * Searches and inserts a getter, loading the key into the stack
     * @param mv The method visitor
     * @param var The data local variable
     * @param key The key
     * @param basicType Whether the type returned will not contain the component
     * @return The type added to the stack
     */
    private MemberType insertGetter(MethodVisitor mv, LocalVariable var, String key, boolean basicType) throws CompilerException {
        for(int i = vars.size() - 1; i >= 0; i--) {
            MemberType type = insertGetter(mv, classes.get(i), vars.get(i), key, basicType);
            if(type != null) return type;
        }

        MemberType type = insertGetter(mv, clazz, var, key, basicType);
        if(type != null) return type;

        throw new CompilerException("Couldn't find any field or method related to " + key);
    }

    /**
     * Tries to inserts a getter, loading the key into the stack
     * @param mv The method visitor
     * @param clazz The data class
     * @param var The data local variable
     * @param key The key
     * @param basicType Whether the type returned will not contain the component
     * @return The type added to the stack or {@code null} if nothing was added
     */
    private MemberType insertGetter(MethodVisitor mv, Class<?> clazz, LocalVariable var, String key, boolean basicType) {
        if (key.equals(".")) {
            // Implicit iterator - We'll return the variable itself instead of looking for a property
            var.load(mv);
            return new MemberType(clazz, Type.getType(clazz));
        }

        Member[] members = findPath(clazz, key);
        if(members == null || members.length == 0) {
            return null;
        }

        // Loads the variable into the stack
        var.load(mv);

        for(int i = 0; i < members.length; i++) {
            Member member = members[i];
            boolean last = i == members.length - 1;

            if(member instanceof Method) {

                // Inserts a method invocation
                Method method = (Method)member;
                Class<?> returnClass = method.getReturnType();
                Class<?> declaringClass = method.getDeclaringClass();
                Type returnType = Type.getType(returnClass);
                boolean itf = declaringClass.isInterface();

                mv.visitMethodInsn(itf ? INVOKEINTERFACE : INVOKEVIRTUAL, Type.getInternalName(declaringClass),
                        method.getName(), Type.getMethodDescriptor(returnType), itf);

                if(last) {
                    return basicType ? new MemberType(returnClass, returnType) : new MemberType(method, returnType);
                }

            } else if(member instanceof Field) {

                // Inserts a field retrieval
                Field field = (Field)member;
                Class<?> fieldClass = field.getType();
                Type fieldType = Type.getType(fieldClass);

                mv.visitFieldInsn(GETFIELD, Type.getInternalName(field.getDeclaringClass()),
                        field.getName(), fieldType.getDescriptor());

                if(last) {
                    return basicType ? new MemberType(fieldClass, fieldType) : new MemberType(field, fieldType);
                }

            }
        }

        // The code should never reach here
        return null;
    }

    /**
     * Finds the object path through fields and getters
     * @param start The start class
     * @param key The path
     * @return The list of members composing this path or {@code null} if the path is invalid
     */
    private Member[] findPath(Class<?> start, String key) {
        Class<?> context = start;
        String[] path = key.split("\\.");
        Member[] members = new Member[path.length];

        for(int i = 0; i < path.length; i++) {
            String k = path[i];

            Method m = getMethod(context, k);
            if(m != null) {
                members[i] = m;
                context = m.getReturnType();
                continue;
            }

            Field f = getField(context, k);
            if(f != null) {
                members[i] = f;
                context = f.getType();
                continue;
            }

            return null;
        }

        return members;
    }

    /**
     * Tries to find a field with the specified name
     * @param clazz The class to look into
     * @param key The field name
     * @return The field or {@code null}
     */
    private Field getField(Class<?> clazz, String key) {
        try {
            return clazz.getField(key);
        } catch(Exception ex) {
            return null;
        }
    }

    /**
     * Tries to find a getter method with the specified name
     * @param clazz The class to look into
     * @param key The method name
     * @return The method or {@code null}
     */
    private Method getMethod(Class<?> clazz, String key) {
        try {
            return clazz.getMethod(key);
        } catch(Exception ignored) {}

        String camelCase = Character.toUpperCase(key.charAt(0)) + key.substring(1);

        try {
            return clazz.getMethod("get" + camelCase);
        } catch(Exception ignored) {}

        try {
            return clazz.getMethod("is" + camelCase);
        } catch(Exception ignored) {}

        return null;
    }
}
